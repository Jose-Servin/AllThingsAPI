# Flask Market Build Notes

Why we did what we did for the FlaskMarket App project.

This project is a simple marketplace application where users can register and login to purchase items. Users also have the ability to sell items previously purchased back to the marketplace. The marketplace is only available to registered users.

## Repo Structure

```terminal
.
├── app
│   ├── __init__.py
│   ├── forms
│   │   ├── __init__.py
│   │   ├── login_form.py
│   │   ├── purchase_item_form.py
│   │   ├── register_form.py
│   │   └── sell_item_form.py
│   ├── instance
│   │   └── market.db
│   ├── models
│   │   ├── __init__.py
│   │   ├── item.py
│   │   └── user.py
│   ├── routes
│   │   ├── __init__.py
│   │   ├── home.py
│   │   ├── login.py
│   │   ├── logout.py
│   │   ├── market.py
│   │   └── register.py
│   └── templates
│       ├── add_item.html
│       ├── base.html
│       ├── home.html
│       ├── includes
│       │   ├── items_modals.html
│       │   └── owned_items_modals.html
│       ├── login.html
│       ├── market.html
│       └── register.html
├── add_item_with_user.py
├── add_user_to_item.py
├── create_item.py
├── create_sample_data.py
├── create_user.py
├── query_item_owner.py
├── remove_user_from_item.py
├── requirements.txt
├── reset_database.py
└── run.py
```

## Running our Application

To run our application, we can execute the `python run.py` command with our virtual environment activated. This will invoke the `create_app()` function which is located in our `app/__init__.py` this is why the import statement is `from app import create_app`.

Code for `run.py`

```python
from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run(debug=True)

```

Code for `app/__init__.py`

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_login import LoginManager

# Initializing Flask extensions
db = SQLAlchemy()
bcrypt = Bcrypt()
login_manager = LoginManager()

# Creating the Flask application factory function


def create_app():
    app = Flask(__name__)

    # Configuring the application
    database_uri = "sqlite:////Users/joseservin/AllThingsFullStack/Flask/FlaskMarket/app/instance/market.db"
    app.config["SQLALCHEMY_DATABASE_URI"] = database_uri
    app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
    app.config["SECRET_KEY"] = "ec9439cfc6c796ae2029594d"

    # Initializing and configuring Flask extensions
    bcrypt.init_app(app)
    login_manager.init_app(app)
    # Configuring what view to return if login_required decorator fails
    login_manager.login_view = "login.login_page"
    login_manager.login_message_category = "info"
    db.init_app(app)

    # Creating database tables
    with app.app_context():
        db.create_all()

    # Import and register blueprints
    from app.routes.home import home_bp
    from app.routes.market import market_bp
    from app.routes.register import register_bp
    from app.routes.login import login_bp
    from app.routes.logout import logout_bp

    app.register_blueprint(home_bp)
    app.register_blueprint(market_bp)
    app.register_blueprint(register_bp)
    app.register_blueprint(login_bp)
    app.register_blueprint(logout_bp)

    # Returning the configured Flask app
    return app


```

## Models

Our Market place will consist of 2 models; one for a `User` and one for an `Item`.

Our Item model consists of the following:

```python
from app import db


class Item(db.Model):
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(length=30), nullable=False, unique=True)
    price = db.Column(db.Integer(), nullable=False)
    barcode = db.Column(db.String(length=12), nullable=False, unique=True)
    description = db.Column(db.String(length=1024),
                            nullable=False, unique=True)
    # Here is where we relate our Item with our User
    owner = db.Column(db.Integer(), db.ForeignKey("user.id"))

    def __repr__(self):
        return f"Item {self.name}"

    def set_owner(self, user):
        # assign ownership to the current user who is logged in
        self.owner = user.id
        # decrease current user budget - item price
        user.budget -= self.price
        db.session.commit()

    def remove_owner(self, user):
        # current user is removed as owner of item
        self.owner = None
        # increase current user budget by item price
        user.budget += self.price
        db.session.commit()

```

Our User model consist of the following:

```python
from app import db, login_manager, bcrypt
from flask_login import UserMixin


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


class User(db.Model, UserMixin):
    id = db.Column(db.Integer(), primary_key=True)
    username = db.Column(db.String(length=30), nullable=False, unique=True)
    email_address = db.Column(db.String(length=50),
                              nullable=False, unique=True)
    # For security reasons, we don't store the password but rather a password_hash
    # We specify a length of 60 because that is the length the hashing algorithm returns.
    password_hash = db.Column(db.String(length=60), nullable=False)
    budget = db.Column(db.Integer(), nullable=False, default=1000)
    # From the relationship we defined, we can view the User if we have an Item
    # by looking at the Item.owned_user
    items = db.relationship("Item", backref="owned_user", lazy=True)

    @property
    def password(self):
        raise AttributeError("Password is not a readable attribute.")

    @password.setter
    def password(self, plain_text_password):
        self.password_hash = bcrypt.generate_password_hash(plain_text_password).decode(
            "utf-8"
        )

    def check_password_correction(self, attempted_password):
        return bcrypt.check_password_hash(self.password_hash, attempted_password)

    # Here we define a property so the call becomes current_user.prettier_budget in our HTML
    @property
    def prettier_budget(self):
        """Get a formatted representation of the budget with commas for thousands.

        Returns:
        str: The budget formatted as a string with commas for thousands.
        """
        return "{:,}".format(self.budget)

    def can_purchase(self, item_to_purchase):
        return self.budget >= item_to_purchase.price

    def can_sell(self, item_to_sell):
        return item_to_sell in self.items

```

Key things to remember:

- We are able to tie our Item and User model by specifying both a `db.relationship()` and a `db.ForeignKey()` The `db.relationship()` in our User model is saying create a relationship between our Item mode, and if you have an item, access it's owner via the `owned_user` attribute.

## Forms

For this example, we will be looking at how our `register_form.py`, `register.html` and `route/register.py` tie together.

First, we defined our `register.py` file which defined what route the user should visit to register and in this route we return an initialization of our register form.

Our form is defined in our `register_form.py` file and contains the fields our user should see plus any validation function that should run when we execute the `form.validate_on_submit()` function.

Finally, in our `register.html` we work with the initialized form object and call present the field to our user by calling them using jinja syntax.

This Form --> Model --> HTML linking is essentially how we combine the font-end with the backend.

## Flask Validations

The three main call-outs with form validations are

1. implementing CSRF protection via `form.hidden_tag()`

    ```html
    <form method="POST" class="form-register" style="color:white">
            {# Used by Flask-WTF to implement CSRF protection #}
            {{ form.hidden_tag() }}
            <img class="mb-4" src="https://res.cloudinary.com/jimshapedcoding/image/upload/v1597332609/android-icon-192x192_ove2a7.png" alt="">
            <h1 class="h3 mb-3 font-weight-normal">
                Please Create your Account
            </h1>
            <br>
            {# This label is coming from our ./forms/register_form.py label definition #}
            {{ form.username.label() }}
            {{ form.username(class="form-control", placeholder="User Name") }}

            {{ form.email_address.label() }}
            {{ form.email_address(class="form-control", placeholder="Email Address") }}

            {{ form.password1.label() }}
            {{ form.password1(class="form-control", placeholder="Password") }}

            {{ form.password2.label() }}
            {{ form.password2(class="form-control", placeholder="Confirm Password") }}

            <br>

            <div class="checkbox mb-3">
                <h6>Already have an account?</h6>
                <a class="btn btn-sm btn-secondary" href="{{ url_for('login.login_page') }}">Login</a>
            </div>

            {{ form.submit(class="btn btn-lg btn-block btn-primary") }}

        </form>
    ```

2. Configuring a secret key due to users POST request.

    ```python
    def create_app():
        app = Flask(__name__)

        # Configuring the application
        database_uri = "sqlite:////Users/joseservin/AllThingsFullStack/Flask/FlaskMarket/app/instance/market.db"
        app.config["SQLALCHEMY_DATABASE_URI"] = database_uri
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        # Secret Key is needed due to form using POST request
        app.config["SECRET_KEY"] = "ec9439cfc6c796ae2029594d"
    ```

3. Form validation & Model validation

    There are two types of validations that are occurring here. The first one is our Form validation code which is for each form field and runs in our `Route` via the `form.validate()` function call.

    Form

    ```python
    username = StringField(
        label="User Name:", validators=[Length(min=2, max=30), DataRequired()]
    )
    email_address = StringField(
        label="Email Address:", validators=[Email(), DataRequired()]
    )
    password1 = PasswordField(
        label="Password:", validators=[Length(min=6), DataRequired()]
    )
    password2 = PasswordField(
        label="Confirm Password:", validators=[EqualTo("password1"), DataRequired()]
    )
    submit = SubmitField(label="Create Account")
    ```

    Route - handles both validation check and errors that occurred due to failed validations.

    ```python
    @register_bp.route("/register", methods=["GET", "POST"])
    def register_page():
        register_form = RegisterForm()
        if request.method == "POST" and register_form.validate():

        ...

        # if the form contains validation errors
        if register_form.errors != {}:
            for err_msg in register_form.errors.values():
                flash(
                    f"There was an error with creating a user: {err_msg}", category="danger"
                )
    ```

    The second type are validation tests that run automatically due to our Form inheriting from the `FlaskForm` class. These type of test start with `validate` prefix and includes a field from our Form. Ex, `validate_username()`.

    It is important we write these validation tests to avoid our Users seeing a `sqlalchemy.IntegrityError`.


    ```python

    # Handling existing username error
    # Flask Forms will automatically execute our validate_x() functions; we must make sure x is a form field.
    # We validate conditions that would go against our User Model and generate SQLAlchemy errors

    def validate_username(self, username_to_check):
        """
        Validate if the provided username already exists in the database.

        Args:
            username_to_check (str): The username to be checked.

        Raises:
            ValidationError: If the username already exists in the database.
        """

        user = User.query.filter_by(username=username_to_check.data).first()
        if user:
            raise ValidationError(
                "Username already exists! Please try a different username"
            )

    # Handling email address already exists
    def validate_email_address(self, email_address_to_check):
        """
        Validate if the provided email address already exists in the database.

        Args:
            email_address_to_check (str): The email address to be checked.

        Raises:
            ValidationError: If the email address already exists in the database.
        """
        email_address = User.query.filter_by(
            email_address=email_address_to_check.data
        ).first()
        if email_address:
            raise ValidationError(
                "Email Address already exists! Please try a different email address"
            )

    ```

Here we see how our `Models` are tied with our `Forms`. In our `Model/User` we specified that the `username` field must be `unique=True`; therefor in our `Form/register_form`, when we submit a new user with an already existing username, we fail the unique constraint check which results in the SQLAlchemy error. And to reiterate, the call to run these validations occur in our `Route/register` `validate()` function.

## Flashing Messages

To flash messages we first write our `flash()` messages in our `route/` and leverage the jinja `get_flashed_messages()` function in our HTML.

Here, we are choosing to flash ALL messages in our `base.html`; this way, we can flash messages in other routes and not have them in each html page for that route.

```html
</nav>
      {% with messages = get_flashed_messages(with_categories=true) %}
         {% if messages %}
            {% for category, message in messages %}
               <div class="alert alert-{{ category }}">
                  <button type="button" class="m1-2 mb-1 close" data-dismiss="alert" aria-label="Close">
                     <span aria-hidden="true">&times;</span>
                  </button>
                  {{ message }}
               </div>
            {% endfor %}
         {% endif %}
      {% endwith %}
```

Even more specific, we flash all messages under our nav. We also make sure to capture categories to then call custom Bootstrap classes that will dynamically change our messages to be either red, green, informative etc.

```python
flash(
    f"Account created successfully! You are now logged in as {
        user_to_create.username}",
        category="success",
    )
```

More info on Bootstrap Alerts can be found [here](https://getbootstrap.com/docs/4.0/components/alerts/)

## Secure Password Storage

For password encryption we use the `Bcrypt` library and initialize the extension in our `app/__init__.py` file.

```python
bcrypt = Bcrypt()
bcrypt.init_app(app)
```

In our User model we have the `password_hash` field which is not really starting out as a password hash has but rather, we convert it to a hash and save it as a new field called `password`.

```python
password_hash = db.Column(db.String(length=60), nullable=False)
```

```python
class User(db.Model, UserMixin):
    id = db.Column(db.Integer(), primary_key=True)
    username = db.Column(db.String(length=30), nullable=False, unique=True)
    email_address = db.Column(db.String(length=50),
                              nullable=False, unique=True)
    # For security reasons, we don't store the password but rather a password_hash
    # We specify a length of 60 because that is the length the hashing algorithm returns.
    password_hash = db.Column(db.String(length=60), nullable=False)
    budget = db.Column(db.Integer(), nullable=False, default=1000)
    # From the relationship we defined, we can view the User if we have an Item
    # by looking at the Item.owned_user
    items = db.relationship("Item", backref="owned_user", lazy=True)

    @property
    def password(self):
        raise AttributeError("Password is not a readable attribute.")

    @password.setter
    def password(self, plain_text_password):
        self.password_hash = bcrypt.generate_password_hash(plain_text_password).decode(
            "utf-8"
        )
```

This new property attribute is created by the `@property` decorator and the rules of defining this new property are defined in the `@setter` method.

This reads as, "Before you create the password attribute, running the setter code."

In our `Route/Register.py` we "set" the password when we create a new User instead of using the `password_hash` to run our `@setter` code.

```python
@register_bp.route("/register", methods=["GET", "POST"])
def register_page():
    register_form = RegisterForm()
    if request.method == "POST" and register_form.validate():
        # Because of the setter method in our User Model,
        # we call password and not password_hash to create a User
        user_to_create = User(
            username=register_form.username.data,
            email_address=register_form.email_address.data,
            password=register_form.password1.data,
        )
```

Again, we use the `password` attribute and not the`password_hash` from our `Models/user` because this calls the `@setter` method of our password attribute. So now, the "plain_text_password" is the `register_form.password1.data` which gets passed to the `@setter` method and we use the `self.password_hash` because our User model contains this field and that's what the User model knows.

So from our User model, we grab this "password_hash" convert it to an actual password hash and save this as a new attribute called "password".

To summarize, here we are seeing how our `Models/user` ties with our `routes/register` because of our `@setter` code and securely stores our Users password.

## Login User

For the login functionality we will be using the `Route/login`, `Form/login_form` adn the `template/login.html`.

### Side Note #1

As we build functionalities to our page, we need to remember to update out navbar if we have a navigation element for these functionalities. For example, here when we are building the login page, we had to go back to our `base.html` and update the `url_for` function for our login `a` tag. Which again, the url_for takes both route and route function.

```html
<a class="nav-link" href="{{ url_for('login.login_page">Login</a>
```

### Side Note #2

When functionalities are closely tied like login and register, we make sure to allow the user to easily navigate between the two actions by tying the html templates via an anchor tag. For example, if a user clicks login but is not registered, we offer a button to quickly go to the register page.

```html
<div class="checkbox mb-3">
    <h6>Already have an account?</h6>
    <a class="btn btn-sm btn-secondary" href="{{ url_for('login.login_page') }}">Login</a>
</div>
```

The login logic is applied via the `LoginManager` package, so in our `app/__init__.py` we need to initialize and register our App.

```python

from flask_login import LoginManager
# ...
login_manager = LoginManager()

# Creating the Flask application factory function

def create_app():
    app = Flask(__name__)
    # ...
    # IInitializing and configuring Flask extensions
    login_manager.init_app(app)
```

When logging in a user, we perform two checks.

1. Does the user already exist?
2. Does the password provided by the User match the hashed password?

The first check is fairly easy, we simply take the information the user submitted via the Login Form and query our Database for that user.

```python
attempted_user = User.query.filter_by(username=form.username.data).first()
```

To perform the second check, we need to take the password submitted by the user and in our `Models/user` perform a decryption operation to see if the password provided is correct. We do this by creating a new method for our User and run this in our `routes/login`. If we don't add this encryption check our passwords would never match and the login functionality would never work.

```python
# Models/user.py
def check_password_correction(self, attempted_password):
    return bcrypt.check_password_hash(self.password_hash, attempted_password)
```

```python
# Routes/login.py
if attempted_user and attempted_user.check_password_correction(attempted_password=form.password.data):
```

After these checks, we can login a user by a simple function call.

```python
from flask import Blueprint, render_template, redirect, url_for, flash
from app.forms.login_form import LoginForm
from app.models.user import User
from flask_login import login_user

login_bp = Blueprint("login", __name__)


@login_bp.route("/login", methods=["GET", "POST"])
def login_page():
    # ...
            login_user(attempted_user)
            flash(
                f"Success! You are logged in as: {attempted_user.username}",
                category="success",
            )
            return redirect(url_for("market.market_page"))
        else:
            # TODO: Ask the user to register
            flash(
                "Username and password do not match! Please try again",
                category="danger",
            )

    return render_template("login.html", form=form)

```

The first time running this code, we ran into an error that said `"Missing user_loader or request_loader"`. To fix this issue, we add the `user_loader` to our `Models/user`.

```python
# Models/user.py
from app import db, login_manager, bcrypt
from flask_login import UserMixin

# User loader callback
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))
```

This callback is what helps Flask understand during refreshes if the user is logged-in or not. How this works is each time we reload a page, this callback runs and verifies the user is logged-in.

From the [flask-login documentation](https://flask-login.readthedocs.io/en/latest/) we also see that our User class needs to inherit from the `UserMixin` class in order to have access to some required methods.

From the docs:

```text
To make implementing a user class easier, you can inherit from UserMixin, which provides default implementations for all of these properties and methods. (It’s not required, though.)
```

```python
# Models/user.py
class User(db.Model, UserMixin):
```

Finally, after having the backend login functionality completed, we go to our frontend `templates/base.html` and dynamically change our navbar based on the condition that the user is logged in.

We do this by using the `current_user.is_authenticated` condition check to say, if the user is logged in change the navbar to show a logout button instead of the login button as well as showing some User specific information.

```html
<div class="collapse navbar-collapse" id="navbarNav">
    <ul class="navbar-nav mr-auto">
        <li class="nav-item active">
            {# the url_for is for the defined route not html #}
            <a class="nav-link" href="{{ url_for('home.home_page') }}"
                >Home <span class="sr-only">(current)</span></a
                >
        </li>
        <li class="nav-item">
            <a class="nav-link" href="{{ url_for('market.market_page') }}">Market</a>
        </li>
    </ul>
    {# current_user is accessible via the flask_login package #}
    {% if current_user.is_authenticated %}
    <ul class="navbar-nav">
        <li class="nav-item">
            <a class="nav-link" style="color: lawngreen; font-weight: bold">
            <i class="ph ph-coins"></i>
            <i>{{ current_user.prettier_budget }}</i>
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link">Welcome, {{ current_user.username }}</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="{{ url_for('logout.logout_page') }}">Logout</a>
        </li>
    </ul>
    {% else %}
    <ul class="navbar-nav">
        <li class="nav-item">
            <a class="nav-link" href="{{ url_for('login.login_page') }}">Login</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="{{ url_for('register.register_page') }}">Register</a>
        </li>
    </ul>
    {% endif %}
</div>
```

A key thing to note here is how `current_user` has access to our `Models/User` methods. For example, to make sure our budget is presented in a nice way we created a "pretty" function in our `Modes/user` and call this function in our `base.html`.

Note how we create this by using a `property` to make the call an attribute access and not a function call.

```python
# Models/user.py
# Here we define a property so the call becomes current_user.prettier_budget in our HTML
@property
def prettier_budget(self):
    """Get a formatted representation of the budget with commas for thousands.
    Returns:
    str: The budget formatted as a string with commas for thousands.
    """
    return "{:,}".format(self.budget)
```

```html
<!-- base.html -->
<li class="nav-item">
    <a class="nav-link" style="color: lawngreen; font-weight: bold">
    <i class="ph ph-coins"></i>
    <i>{{ current_user.prettier_budget }}</i>
    </a>
</li>
```

## Logout User

The logout functionality is fairly simple, we first create a `route/logout` and create a condition that the user must be logged in in order to invoke this route. We then use a built-in flask logout method to complete the process.

The important part of this process is to remember to use the `@login_required` decorator in our logout route definition.

```python
#routes/logout.py
from flask import Blueprint, redirect, url_for, flash
from flask_login import logout_user, login_required

logout_bp = Blueprint("logout", __name__)


@logout_bp.route("/logout")
@login_required
def logout_page():
    logout_user()
    flash("You have been logged out!", category="info")
    # this url_for is calling a route NOT an html template
    return redirect(url_for("home.home_page"))

```

In our `base.html` we use the `url_for` function on the anchor tag for logout.

```html
{% if current_user.is_authenticated %}
   <ul class="navbar-nav">
      <li class="nav-item">
         <a class="nav-link" style="color: lawngreen; font-weight: bold">
            <i class="ph ph-coins"></i>
            <!-- prettier_budget comes from our Models/user -->
            <i>{{ current_user.prettier_budget }}</i>
         </a>
      </li>
      <li class="nav-item">
         <a class="nav-link">Welcome, {{ current_user.username }}</a>
      </li>
      <li class="nav-item">
         <a class="nav-link" href="{{ url_for('logout.logout_page') }}">Logout</a>
      </li>
   </ul>
{% else %}
```

## Home Page Logic

The home page contains a "Get Started" button that takes our users to the `market.html`. However, before a user can navigate to this page, the user MUST be logged in. Therefore, we make a correction to our `routes/market.py` and add the `login_required()` decorator.

```python
# routes/market.py

@market_bp.route("/market", methods=["GET", "POST"])
@login_required
def market_page():
    purchase_form = PurchaseForm()
    selling_form = SellItemForm()
```

The next part of this process is defining what to do if the user is NOT logged in yet but is attempting to view the market page. We need to redirect him to the `login.html`, this is done by defining our `route/login.login_page` as our login_view.

So, the conditions are:

1. If the user is logged in, proceed to market page. (Implemented with decorator)

2. If the user is not logged in, redirect to login page. (Implemented with login_manager.login_view)

We redirect the user by defining our `login_view` in our `app/__init__.py` file. Note here that the login_manager will automatically flash messages so all we have to do is define what category to flash these messages under.

```python
#app/__init__.py

# Configuring what view to return if login_required decorator fails (Specifically, what route to run to return this view)
login_manager.login_view = "login.login_page"
login_manager.login_message_category = "info"
```

After testing this redirection, in the URL we should see `{port}/login?next=%2Fmarket` which is confirming that after the user logs in, he will be redirected to our market page.

The last change we made was to our `route/register` which is currently registering a user but then asks them to login. It attempts to take them to the marketplace because that is our `redirect` BUT since the user is not logged in they are asked to do so. To improve the user experience, we automatically log in the user which will allow them to successfully redirect to our market page.

```python
#routes/register.py

# After registering, the user is redirect to the market.market_page route
login_user(user_to_create)
flash(
    f"Account created successfully! You are now logged in as {
        user_to_create.username}",
    category="success",
)
# here we are providing a route not an HTML template
return redirect(url_for("market.market_page"))
```

## Item Purchasing Part 1

The first change we made in order to add the Item Purchasing functionality was a front-end change to our `market.html`. Here, we leveraged Bootstrap's grid system to place Available Items on one side of the market place page and Owned Items on the other.

```html
{% extends 'base.html' %}
{% block title %}
Market Page
{% endblock %}
{% block content %}
<h1>Market Page</h1>
<div class="row" style="margin-top:20px; margin-left:20px">
   <div class="col-8">
   </div>
   <div class="col-4">
   </div>
</div>
{% endblock %}
```

### Modal Windows

Modal windows allow us to focus our user on a certain piece of information. For this project, we will build several to confirm critical actions before they take place like purchasing, reading more about an item and selling an item.