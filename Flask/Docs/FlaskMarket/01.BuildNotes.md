# Flask Market Build Notes

Why we did what we did for the FlaskMarket App project.

This project is a simple marketplace application where users can register and login to purchase items. Users also have the ability to sell items previously purchased back to the marketplace. The marketplace is only available to registered users.

## Repo Structure

```terminal
.
├── app
│   ├── __init__.py
│   ├── forms
│   │   ├── __init__.py
│   │   ├── login_form.py
│   │   ├── purchase_item_form.py
│   │   ├── register_form.py
│   │   └── sell_item_form.py
│   ├── instance
│   │   └── market.db
│   ├── models
│   │   ├── __init__.py
│   │   ├── item.py
│   │   └── user.py
│   ├── routes
│   │   ├── __init__.py
│   │   ├── home.py
│   │   ├── login.py
│   │   ├── logout.py
│   │   ├── market.py
│   │   └── register.py
│   └── templates
│       ├── add_item.html
│       ├── base.html
│       ├── home.html
│       ├── includes
│       │   ├── items_modals.html
│       │   └── owned_items_modals.html
│       ├── login.html
│       ├── market.html
│       └── register.html
├── add_item_with_user.py
├── add_user_to_item.py
├── create_item.py
├── create_sample_data.py
├── create_user.py
├── query_item_owner.py
├── remove_user_from_item.py
├── requirements.txt
├── reset_database.py
└── run.py
```

## Running our Application

To run our application, we can execute the `python run.py` command with our virtual environment activated. This will invoke the `create_app()` function which is located in our `app/__init__.py` this is why the import statement is `from app import create_app`.

Code for `run.py`

```python
from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run(debug=True)

```

Code for `app/__init__.py`

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_login import LoginManager

# Initializing Flask extensions
db = SQLAlchemy()
bcrypt = Bcrypt()
login_manager = LoginManager()

# Creating the Flask application factory function


def create_app():
    app = Flask(__name__)

    # Configuring the application
    database_uri = "sqlite:////Users/joseservin/AllThingsFullStack/Flask/FlaskMarket/app/instance/market.db"
    app.config["SQLALCHEMY_DATABASE_URI"] = database_uri
    app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
    app.config["SECRET_KEY"] = "ec9439cfc6c796ae2029594d"

    # Initializing and configuring Flask extensions
    bcrypt.init_app(app)
    login_manager.init_app(app)
    # Configuring what view to return if login_required decorator fails
    login_manager.login_view = "login.login_page"
    login_manager.login_message_category = "info"
    db.init_app(app)

    # Creating database tables
    with app.app_context():
        db.create_all()

    # Import and register blueprints
    from app.routes.home import home_bp
    from app.routes.market import market_bp
    from app.routes.register import register_bp
    from app.routes.login import login_bp
    from app.routes.logout import logout_bp

    app.register_blueprint(home_bp)
    app.register_blueprint(market_bp)
    app.register_blueprint(register_bp)
    app.register_blueprint(login_bp)
    app.register_blueprint(logout_bp)

    # Returning the configured Flask app
    return app


```

## Models

Our Market place will consist of 2 models; one for a `User` and one for an `Item`.

Our Item model consists of the following:

```python
from app import db


class Item(db.Model):
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(length=30), nullable=False, unique=True)
    price = db.Column(db.Integer(), nullable=False)
    barcode = db.Column(db.String(length=12), nullable=False, unique=True)
    description = db.Column(db.String(length=1024),
                            nullable=False, unique=True)
    # Here is where we relate our Item with our User
    owner = db.Column(db.Integer(), db.ForeignKey("user.id"))

    def __repr__(self):
        return f"Item {self.name}"

    def set_owner(self, user):
        # assign ownership to the current user who is logged in
        self.owner = user.id
        # decrease current user budget - item price
        user.budget -= self.price
        db.session.commit()

    def remove_owner(self, user):
        # current user is removed as owner of item
        self.owner = None
        # increase current user budget by item price
        user.budget += self.price
        db.session.commit()

```

Our User model consist of the following:

```python
from app import db, login_manager, bcrypt
from flask_login import UserMixin


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


class User(db.Model, UserMixin):
    id = db.Column(db.Integer(), primary_key=True)
    username = db.Column(db.String(length=30), nullable=False, unique=True)
    email_address = db.Column(db.String(length=50),
                              nullable=False, unique=True)
    # For security reasons, we don't store the password but rather a password_hash
    # We specify a length of 60 because that is the length the hashing algorithm returns.
    password_hash = db.Column(db.String(length=60), nullable=False)
    budget = db.Column(db.Integer(), nullable=False, default=1000)
    # From the relationship we defined, we can view the User if we have an Item
    # by looking at the Item.owned_user
    items = db.relationship("Item", backref="owned_user", lazy=True)

    @property
    def password(self):
        raise AttributeError("Password is not a readable attribute.")

    @password.setter
    def password(self, plain_text_password):
        self.password_hash = bcrypt.generate_password_hash(plain_text_password).decode(
            "utf-8"
        )

    def check_password_correction(self, attempted_password):
        return bcrypt.check_password_hash(self.password_hash, attempted_password)

    # Here we define a property so the call becomes current_user.prettier_budget in our HTML
    @property
    def prettier_budget(self):
        """Get a formatted representation of the budget with commas for thousands.

        Returns:
        str: The budget formatted as a string with commas for thousands.
        """
        return "{:,}".format(self.budget)

    def can_purchase(self, item_to_purchase):
        return self.budget >= item_to_purchase.price

    def can_sell(self, item_to_sell):
        return item_to_sell in self.items

```

Key things to remember:

- We are able to tie our Item and User model by specifying both a `db.relationship()` and a `db.ForeignKey()` The `db.relationship()` in our User model is saying create a relationship between our Item mode, and if you have an item, access it's owner via the `owned_user` attribute.

## Forms

For this example, we will be looking at how our `register_form.py`, `register.html` and `route/register.py` tie together.

First, we defined our `register.py` file which defined what route the user should visit to register and in this route we return an initialization of our register form.

Our form is defined in our `register_form.py` file and contains the fields our user should see plus any validation function that should run when we execute the `form.validate_on_submit()` function.

Finally, in our `register.html` we work with the initialized form object and call present the field to our user by calling them using jinja syntax.

This Form --> Model --> HTML linking is essentially how we combine the font-end with the backend.

## Flask Validations

The three main call-outs with form validations are

1. implementing CSRF protection via `form.hidden_tag()`

    ```html
    <form method="POST" class="form-register" style="color:white">
            {# Used by Flask-WTF to implement CSRF protection #}
            {{ form.hidden_tag() }}
            <img class="mb-4" src="https://res.cloudinary.com/jimshapedcoding/image/upload/v1597332609/android-icon-192x192_ove2a7.png" alt="">
            <h1 class="h3 mb-3 font-weight-normal">
                Please Create your Account
            </h1>
            <br>
            {# This label is coming from our ./forms/register_form.py label definition #}
            {{ form.username.label() }}
            {{ form.username(class="form-control", placeholder="User Name") }}

            {{ form.email_address.label() }}
            {{ form.email_address(class="form-control", placeholder="Email Address") }}

            {{ form.password1.label() }}
            {{ form.password1(class="form-control", placeholder="Password") }}

            {{ form.password2.label() }}
            {{ form.password2(class="form-control", placeholder="Confirm Password") }}

            <br>

            <div class="checkbox mb-3">
                <h6>Already have an account?</h6>
                <a class="btn btn-sm btn-secondary" href="{{ url_for('login.login_page') }}">Login</a>
            </div>

            {{ form.submit(class="btn btn-lg btn-block btn-primary") }}

        </form>
    ```

2. Configuring a secret key due to users POST request.

    ```python
    def create_app():
        app = Flask(__name__)

        # Configuring the application
        database_uri = "sqlite:////Users/joseservin/AllThingsFullStack/Flask/FlaskMarket/app/instance/market.db"
        app.config["SQLALCHEMY_DATABASE_URI"] = database_uri
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        # Secret Key is needed due to form using POST request
        app.config["SECRET_KEY"] = "ec9439cfc6c796ae2029594d"
    ```

3. Form validation & Model validation

    There are two types of validations that are occurring here. The first one is our Form validation code which is for each form field and runs in our `Route` via the `form.validate()` function call.

    Form

    ```python
    username = StringField(
        label="User Name:", validators=[Length(min=2, max=30), DataRequired()]
    )
    email_address = StringField(
        label="Email Address:", validators=[Email(), DataRequired()]
    )
    password1 = PasswordField(
        label="Password:", validators=[Length(min=6), DataRequired()]
    )
    password2 = PasswordField(
        label="Confirm Password:", validators=[EqualTo("password1"), DataRequired()]
    )
    submit = SubmitField(label="Create Account")
    ```

    Route - handles both validation check and errors that occurred due to failed validations.

    ```python
    @register_bp.route("/register", methods=["GET", "POST"])
    def register_page():
        register_form = RegisterForm()
        if request.method == "POST" and register_form.validate():

        ...

        # if the form contains validation errors
        if register_form.errors != {}:
            for err_msg in register_form.errors.values():
                flash(
                    f"There was an error with creating a user: {err_msg}", category="danger"
                )
    ```

    The second type are validation tests that run automatically due to our Form inheriting from the `FlaskForm` class. These type of test start with `validate` prefix and includes a field from our Form. Ex, `validate_username()`.

    It is important we write these validation tests to avoid our Users seeing a `sqlalchemy.IntegrityError`.


    ```python

    # Handling existing username error
    # Flask Forms will automatically execute our validate_x() functions; we must make sure x is a form field.
    # We validate conditions that would go against our User Model and generate SQLAlchemy errors

    def validate_username(self, username_to_check):
        """
        Validate if the provided username already exists in the database.

        Args:
            username_to_check (str): The username to be checked.

        Raises:
            ValidationError: If the username already exists in the database.
        """

        user = User.query.filter_by(username=username_to_check.data).first()
        if user:
            raise ValidationError(
                "Username already exists! Please try a different username"
            )

    # Handling email address already exists
    def validate_email_address(self, email_address_to_check):
        """
        Validate if the provided email address already exists in the database.

        Args:
            email_address_to_check (str): The email address to be checked.

        Raises:
            ValidationError: If the email address already exists in the database.
        """
        email_address = User.query.filter_by(
            email_address=email_address_to_check.data
        ).first()
        if email_address:
            raise ValidationError(
                "Email Address already exists! Please try a different email address"
            )

    ```

Here we see how our `Models` are tied with our `Forms`. In our `Model/User` we specified that the `username` field must be `unique=True`; therefor in our `Form/register_form`, when we submit a new user with an already existing username, we fail the unique constraint check which results in the SQLAlchemy error. And to reiterate, the call to run these validations occur in our `Route/register` `validate()` function.

## Flashing Messages

To flash messages we first write our `flash()` messages in our `route/` and leverage the jinja `get_flashed_messages()` function in our HTML.

Here, we are choosing to flash ALL messages in our `base.html`; this way, we can flash messages in other routes and not have them in each html page for that route.

```html
</nav>
      {% with messages = get_flashed_messages(with_categories=true) %}
         {% if messages %}
            {% for category, message in messages %}
               <div class="alert alert-{{ category }}">
                  <button type="button" class="m1-2 mb-1 close" data-dismiss="alert" aria-label="Close">
                     <span aria-hidden="true">&times;</span>
                  </button>
                  {{ message }}
               </div>
            {% endfor %}
         {% endif %}
      {% endwith %}
```

Even more specific, we flash all messages under our nav. We also make sure to capture categories to then call custom Bootstrap classes that will dynamically change our messages to be either red, green, informative etc.

```python
flash(
    f"Account created successfully! You are now logged in as {
        user_to_create.username}",
        category="success",
    )
```

More info on Bootstrap Alerts can be found [here](https://getbootstrap.com/docs/4.0/components/alerts/)

## Secure Password Storage

For password encryption we use the `Bcrypt` library and initialize the extension in our `app/__init__.py` file.

```python
bcrypt = Bcrypt()
bcrypt.init_app(app)
```

In our User model we have the `password_hash` field which is not really starting out as a password hash has but rather, we convert it to a hash and save it as a new field called `password`.

```python
password_hash = db.Column(db.String(length=60), nullable=False)
```

```python
class User(db.Model, UserMixin):
    id = db.Column(db.Integer(), primary_key=True)
    username = db.Column(db.String(length=30), nullable=False, unique=True)
    email_address = db.Column(db.String(length=50),
                              nullable=False, unique=True)
    # For security reasons, we don't store the password but rather a password_hash
    # We specify a length of 60 because that is the length the hashing algorithm returns.
    password_hash = db.Column(db.String(length=60), nullable=False)
    budget = db.Column(db.Integer(), nullable=False, default=1000)
    # From the relationship we defined, we can view the User if we have an Item
    # by looking at the Item.owned_user
    items = db.relationship("Item", backref="owned_user", lazy=True)

    @property
    def password(self):
        raise AttributeError("Password is not a readable attribute.")

    @password.setter
    def password(self, plain_text_password):
        self.password_hash = bcrypt.generate_password_hash(plain_text_password).decode(
            "utf-8"
        )
```

This new property attribute is created by the `@property` decorator and the rules of defining this new property are defined in the `@setter` method.

This reads as, "Before you create the password attribute, running the setter code."

In our `Route/Register.py` we "set" the password when we create a new User instead of using the `password_hash` to run our `@setter` code.

```python
@register_bp.route("/register", methods=["GET", "POST"])
def register_page():
    register_form = RegisterForm()
    if request.method == "POST" and register_form.validate():
        # Because of the setter method in our User Model,
        # we call password and not password_hash to create a User
        user_to_create = User(
            username=register_form.username.data,
            email_address=register_form.email_address.data,
            password=register_form.password1.data,
        )
```

Again, we use the `password` attribute and not the`password_hash` from our `Models/user` because this calls the `@setter` method of our password attribute. So now, the "plain_text_password" is the `register_form.password1.data` which gets passed to the `@setter` method and we use the `self.password_hash` because our User model contains this field and that's what the User model knows.

So from our User model, we grab this "password_hash" convert it to an actual password hash and save this as a new attribute called "password".

To summarize, here we are seeing how our `Models/user` ties with our `routes/register` because of our `@setter` code and securely stores our Users password.
