# Flask Market Build Notes

Why we did what we did for the FlaskMarket App project.

This project is a simple marketplace application where users can register and login to purchase items. Users also have the ability to sell items previously purchased back to the marketplace. The marketplace is only available to registered users.

## Repo Structure

```terminal
.
├── app
│   ├── __init__.py
│   ├── forms
│   │   ├── __init__.py
│   │   ├── login_form.py
│   │   ├── purchase_item_form.py
│   │   ├── register_form.py
│   │   └── sell_item_form.py
│   ├── instance
│   │   └── market.db
│   ├── models
│   │   ├── __init__.py
│   │   ├── item.py
│   │   └── user.py
│   ├── routes
│   │   ├── __init__.py
│   │   ├── home.py
│   │   ├── login.py
│   │   ├── logout.py
│   │   ├── market.py
│   │   └── register.py
│   └── templates
│       ├── add_item.html
│       ├── base.html
│       ├── home.html
│       ├── includes
│       │   ├── items_modals.html
│       │   └── owned_items_modals.html
│       ├── login.html
│       ├── market.html
│       └── register.html
├── add_item_with_user.py
├── add_user_to_item.py
├── create_item.py
├── create_sample_data.py
├── create_user.py
├── query_item_owner.py
├── remove_user_from_item.py
├── requirements.txt
├── reset_database.py
└── run.py
```

## Running our Application

To run our application, we can execute the `python run.py` command with our virtual environment activated. This will invoke the `create_app()` function which is located in our `app/__init__.py` this is why the import statement is `from app import create_app`.

Code for `run.py`

```python
from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run(debug=True)

```

Code for `app/__init__.py`

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_login import LoginManager

# Initializing Flask extensions
db = SQLAlchemy()
bcrypt = Bcrypt()
login_manager = LoginManager()

# Creating the Flask application factory function


def create_app():
    app = Flask(__name__)

    # Configuring the application
    database_uri = "sqlite:////Users/joseservin/AllThingsFullStack/Flask/FlaskMarket/app/instance/market.db"
    app.config["SQLALCHEMY_DATABASE_URI"] = database_uri
    app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
    app.config["SECRET_KEY"] = "ec9439cfc6c796ae2029594d"

    # Initializing and configuring Flask extensions
    bcrypt.init_app(app)
    login_manager.init_app(app)
    # Configuring what view to return if login_required decorator fails
    login_manager.login_view = "login.login_page"
    login_manager.login_message_category = "info"
    db.init_app(app)

    # Creating database tables
    with app.app_context():
        db.create_all()

    # Import and register blueprints
    from app.routes.home import home_bp
    from app.routes.market import market_bp
    from app.routes.register import register_bp
    from app.routes.login import login_bp
    from app.routes.logout import logout_bp

    app.register_blueprint(home_bp)
    app.register_blueprint(market_bp)
    app.register_blueprint(register_bp)
    app.register_blueprint(login_bp)
    app.register_blueprint(logout_bp)

    # Returning the configured Flask app
    return app


```

## Models

Our Market place will consist of 2 models; one for a `User` and one for an `Item`.

Our Item model consists of the following:

```python
from app import db


class Item(db.Model):
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(length=30), nullable=False, unique=True)
    price = db.Column(db.Integer(), nullable=False)
    barcode = db.Column(db.String(length=12), nullable=False, unique=True)
    description = db.Column(db.String(length=1024),
                            nullable=False, unique=True)
    # Here is where we relate our Item with our User
    owner = db.Column(db.Integer(), db.ForeignKey("user.id"))

    def __repr__(self):
        return f"Item {self.name}"

    def set_owner(self, user):
        # assign ownership to the current user who is logged in
        self.owner = user.id
        # decrease current user budget - item price
        user.budget -= self.price
        db.session.commit()

    def remove_owner(self, user):
        # current user is removed as owner of item
        self.owner = None
        # increase current user budget by item price
        user.budget += self.price
        db.session.commit()

```

Our User model consist of the following:

```python
from app import db, login_manager, bcrypt
from flask_login import UserMixin


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


class User(db.Model, UserMixin):
    id = db.Column(db.Integer(), primary_key=True)
    username = db.Column(db.String(length=30), nullable=False, unique=True)
    email_address = db.Column(db.String(length=50),
                              nullable=False, unique=True)
    # For security reasons, we don't store the password but rather a password_hash
    # We specify a length of 60 because that is the length the hashing algorithm returns.
    password_hash = db.Column(db.String(length=60), nullable=False)
    budget = db.Column(db.Integer(), nullable=False, default=1000)
    # From the relationship we defined, we can view the User if we have an Item
    # by looking at the Item.owned_user
    items = db.relationship("Item", backref="owned_user", lazy=True)

    @property
    def password(self):
        raise AttributeError("Password is not a readable attribute.")

    @password.setter
    def password(self, plain_text_password):
        self.password_hash = bcrypt.generate_password_hash(plain_text_password).decode(
            "utf-8"
        )

    def check_password_correction(self, attempted_password):
        return bcrypt.check_password_hash(self.password_hash, attempted_password)

    # Here we define a property so the call becomes current_user.prettier_budget in our HTML
    @property
    def prettier_budget(self):
        """Get a formatted representation of the budget with commas for thousands.

        Returns:
        str: The budget formatted as a string with commas for thousands.
        """
        return "{:,}".format(self.budget)

    def can_purchase(self, item_to_purchase):
        return self.budget >= item_to_purchase.price

    def can_sell(self, item_to_sell):
        return item_to_sell in self.items

```

Key things to remember:

- We are able to tie our Item and User model by specifying both a `db.relationship()` and a `db.ForeignKey()` The `db.relationship()` in our User model is saying create a relationship between our Item mode, and if you have an item, access it's owner via the `owned_user` attribute.

## Forms

For this example, we will be looking at how our `register_form.py`, `register.html` and `route/register.py` tie together.

First, we defined our `register.py` file which defined what route the user should visit to register and in this route we return an initialization of our register form.

Our form is defined in our `register_form.py` file and contains the fields our user should see plus any validation function that should run when we execute the `form.validate_on_submit()` function.

Finally, in our `register.html` we work with the initialized form object and call present the field to our user by calling them using jinja syntax.

This Form --> Model --> HTML linking is essentially how we combine the font-end with the backend.
